import { assert } from 'chai';

import * as decl from '../../src/syntax/ast';
import { TInteger, TFunction, TUnknown } from '../../src/typecheck/types';
import { DummyNode, int, loc, createInstance, o } from './test_utils';


describe('Declaration Nodes', () => {
    describe('FunctionDeclaration', () => {
        it('should resolve the type of a function', () => {
            const func = createInstance(decl.FunctionDeclaration, {
                name: 'myFunc',
                returnType: new DummyNode(int),
                params: [
                    new DummyNode(int),
                    new DummyNode(int),
                ],
                body: new DummyNode(int),
            });
            assert.deepEqual(func.resolveType(o(), o()), new TFunction([int, int], int));
        });

        it('should resolve a function to unknown for an unknown param type', () => {
            const func = createInstance(decl.FunctionDeclaration, {
                name: 'myFunc',
                returnType: new DummyNode(int),
                params: [
                    new DummyNode(new TUnknown()),
                    new DummyNode(int),
                ],
                body: new DummyNode(int),
            });
            assert.deepEqual(func.resolveType(o(), o()), new TUnknown());
        });

        it('should resolve a function to unknown for an unknown return type', () => {
            const func = createInstance(decl.FunctionDeclaration, {
                name: 'myFunc',
                returnType: new DummyNode(new TUnknown()),
                params: [
                    new DummyNode(int),
                    new DummyNode(int),
                ],
                body: new DummyNode(int),
            });
            assert.deepEqual(func.resolveType(o(), o()), new TUnknown());
        });

        it('should have an error in the case of a type mismatch between return type and body', () => {
            const func = createInstance(decl.FunctionDeclaration, {
                name: 'myFunc',
                returnType: new DummyNode(int, { self: loc }),
                params: [
                    new DummyNode(int),
                    new DummyNode(int),
                ],
                body: new DummyNode(new TInteger(64, true)),
            });
            const errors = [];
            func.resolveType({ errors }, { path: '/index.ren' });
            assert.strictEqual(errors.length, 1);
            assert.deepEqual(errors[0].message, 'Type "signed 64-bit integer" is not assignable to type "signed 32-bit integer" [/index.ren:1:1]');
        });

        it('should resolve a parameter type from the type node', () => {
            const param = createInstance(decl.Param, {
                typeNode: new DummyNode(int),
                name: 'param1',
            });
            assert.deepEqual(param.resolveType(o(), o(), o()), int);
        });
    });

    describe('TypeDeclaration', () => {
        it('should resolve a type declaration from the type node', () => {
            const type = createInstance(decl.TypeDeclaration, {
                typeNode: new DummyNode(int),
                name: 'myType',
            });
            assert.deepEqual(type.resolveType(o(), o()), int);
        });
    });

    describe('ExportDeclaration', () => {
        it('should resolve an export from the value', () => {
            const exp = createInstance(decl.ExportDeclaration, {
                name: 'myExport',
                value: new DummyNode(int),
            });
            assert.deepEqual(exp.resolveType(o(), o()), int);
        });
    });
});
