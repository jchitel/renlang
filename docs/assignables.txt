ASSIGNABLES (depends on IMPORT/EXPORT ADDITIONS)

DESCRIPTION:

As of now, the only way to assign things is to use local variables. Obviously, other things are assignable:
- fields/properties of structs/classes
- array indices
- this variable in class constructors
Eventually:
- destructuring
  - array destructuring
  - array rest
  - struct destructuring
  - struct rest

To support these things, we need assignable expressions.
Assignable expressions are a subset of expressions that can appear on the left side of an assignment statement.

NEW SYNTACTIC FEATURES:

New Tokens:
-----------
none

New NonTerminals:
-----------------
Assignment ::= AssignableExpression EQUALS Expression
AssignableExpression ::= THIS
                       | IDENT
                       | FieldAccess
                       | ArrayAccess

Extended NonTerminals:
----------------------
Expression ::= INTEGER_LITERAL |
               FLOATING_POINT_LITERAL |
               STRING_LITERAL |
               CHARACTER_LITERAL |
               VALUE |
               ArrayLiteral |
               StructLiteral |
               TupleLiteral |
               FunctionApplication |
               UnaryOperation |
               BinaryOperation |
               Assignment |           -- replaces VarDeclaration
               AssignableExpression | -- replaces FieldAccess, ArrayAccess, IDENT, and THIS
               LambdaExpression |
               IfElseExpression |
               MethodInvocation |
               MethodReference |
               NewObject |
               SuperCall |
               SuperMethodCall |
               LPAREN Expression RPAREN

NEW SEMANTIC FEATURES:

- Assignments behave the same way as VarDeclarations
- But this time there are things on the left side that already have a type, and are not inferred
- The right side needs to be assignable to the left side

TRANSFORMATION:

- Assignable expressions will almost certainly require some sort of reference resolution logic