
- Not being able to instantiate classes is pretty annoying.
  - We may need to add classes, too much of the existing logic depends on it.
  - Classes are inspired by C# and TypeScript.
  - Classes are declarable wherever types can be declared, and used wherever types are used.
  - Classes can contain a constructor(s), which is a function that receives parameters and an implicit `this` variable, and must return an instance of the class (it can be different from `this`).
  - Classes can contain fields, which mirror the syntax of struct type fields, and can also contain an initializer
  - Classes can contain methods, with the syntax `<type> <name>(<...params>) => <body>`. This will need ambiguity resolution logic with fields.
  - Classes can contain properties, with the syntax `<type> <name> { get => <body> set => <body with value> }`. Either get or set are optional.
    - Shorthand properties are of the form `<type> <name> { get set }` where set is optional, in which case an initializer is required: `<type> <name> { get } = <value>` or in the constructor(s).
  - Classes can inherit from other classes using the extends keyword, and implement interfaces using the implements keyword.
  - Classes labelled sealed cannot be overridden.
  - Any member of a class can be private, meaning that it is only accessible from inside the class. Class members are private by default.
  - Any member of a class can be protected, meaning that it is only accessible from the class and subclasses.
  - Any member of a class can be public, meaning that it is accessible anywhere the class is imported.
  - Methods and properties can be abstract, in which case the class must be abstract. Abstract members may omit bodies, but any non-abstract child class must implement them.
    - For abstract members with bodies, child classes can implement them using the super keyword
  - Methods and properties can be virtual, allowing subclasses to override them.
  - Any class wishing to override a member must use the override keyword.
  - Methods and properties not labelled virtual cannot be overridden.
  - Static members are *not* a thing in this language because there are far simpler alternatives.
  - Assignability with classes:
    - Any value is assignable to a class type if its type is the class or one of the classes child types.
    - Because of this, it is possible for the runtime type of an instance to be more specific than its compile time type.
    - This is contrary to primitive values, which will be coerced to the compile time type.
    - The is operator and getType() method are required to inspect the runtime type of an instance.
    - An important thing that differentiates classes from other types is that classes are not structural types. Assignability is determined nominally, and the structure does not matter.
      - An interesting thing here is that class instances *are* assignable to struct types if the fields match, but *not* the other way around.
  - Using classes:
    - Classes are instantiated using the new keyword followed by the class name and a set of arguments that match one of the constructors.
    - This is an expression that returns an instance of the class corresponding to the chosen constructor.
    - Methods and properties can access class members using the special `this` value, which always points to the current instance of the class.
    - If `this` is omitted, class members are last in the precedence order for resolving ambiguities, thus the order is:
      - scope variables (recursively upwards to the top scope of the function)
      - module-scoped names
      - class members
    - `super` is a special form of `this` that allows access to ancestors' members.
    - `super()` in a constructor allows parent constructors to be called. `super` must be called at some point during any child constructor.
- Arrays, being a type that has a type parameter, are going to prove problematic when doing generic array operations.
  - We may need generic types and type parameters.
  - Any type or function can be generic, meaning that it has at least one type parameter.
  - Type parameters are declared between triangle brackets:
    - Types: `type MyType<{params}>` or `class MyClass<{params}>`
    - Functions: `func {type} myFunc<{Tparams}>({params}) => {body}`
  - Type parameters, like regular parameters, add their names to their scope.
  - Generic types can use their type parameters in their type definitions.
  - Generic classes can use their type parameters in any of their field types, function signatures, and logic.
  - Generic functions can use their type parameters in their signatures and logic.
  - When using generic types, the type parameters must be specified.
  - When using generic functions, the type parameters are omitted because they can be inferred.
  - Function return types can only use type parameters if the parameters use them as well, as the type cannot be inferred otherwise.
  - Any time a generic is used, a copy is *not* created, but that particular instance of usage has the type parameter filled with whatever type is used.
  - Generics allow for extremely complex type logic, for example a type can use itself as a type parameter in the type of a containing element.
  - There is also the concept of covariance (+), contravariance (-), and invariance (default):
    - If a generic type has a covariant type parameter, then assignability between two instances of the type follows the same assignability rules as the type arguments.
      - Ex: a read-only list or a function return type, any read-only value
    - If a generic type has a contravariant type parameter, then assignability between two instances follows the opposite rules as the arguments.
      - Ex: a write-only value or a function parameter type, any write-only value
    - If a generic type has an invariant type parameter (default), then the only type assignable to an instance is the same instance.
      - Ex: a read-write list or array, any read-write value
  - Constraints can also be specified on the type parameters:
    - The type must be assignable to a specific type (T > {type})
    - The type must be assignable from a specific type (T < {type})
- Function overloads are going to be hard to live without.
  - More than one function with the same name can be declared as long as they have different parameter types (assignability between parameter types is ignored).
  - Exporting a function that is overloaded only exports that function, not the overloads.
  - When invoking a function with overloads, the most specific type is attempted to be matched.
  - From an implementation standpoint, each set of overloads is stored under a single function. The presence of overloads overrides the behavior of type checking.
- Extensions
  - Extensions allow logic to be tied to other types in the same way that methods tie logic to classes.
  - Extensions can be declared inline with types using the with keyword, followed by a block of methods.
  - These extension methods can use `this` to refer to an instance of the type.
  - Those methods are then usable on instances of the type.
  - Extensions are public by default, and can be set to private.
  - Extensions can also be added to already declared types, however for safety and explicitness this requires the declaration of a new type.
  - To use separate extensions like these, the new type must be imported, and the extension name must be used wherever the extension is desired. But because the extension is structurally equivalent to the original type, values of the original type are automatically assignable to the extension.
  - Per project, this will usually result in a single extension type with the prefix "Ext" or something to that extent.
  - Unless the extensions are part of an API, they should not be exposed to consumers.
  - Eventually documentation generators will be able to resolve extension types down to the original types.
    - For example, say we have a library that uses int extension methods (intext), and we declare an API function that uses intext, but we don't want intext to be accessible to end users.
    - A documentation generator will analyze and see that the exported function uses an unexported type, and will resolve that type down to components that are accessible to the user, in this case just "int".
  - It is not recommended to add extenstions to structs, because that is getting too close to classes, but it is definitely possible.
- Interfaces
  - Interfaces are another sort of type, which can be assignable from any sort of type as long as the structure matches.
  - Interfaces are already sort of possible by declaring type aliases, but interfaces go further.
  - Classes can explicitly implement interfaces, which adds a step to type checking.
  - Any type that structurally matches the interface (by the same rules as structs) can be assignable to it.
  - Interfaces can contain methods as well, so they can be restricted to any value that declares those methods, either a class or an extension type.
  - Interfaces contain no logic, have no public/private or inheritance modifiers. They only contain fields and/or method signatures and/or properties.
  - When interfaces apply to classes, they must only apply to the public interface of the class, private/protected members are ignored.