----
Base Grammar
----
This will be the grammar that we start out with and gradually add features to. We need a base level that works because it's hard to enumerate all features.
Here are the features that will be included:
- functions
  - functions are first-class
- pointers (this will make certain things easier, later revisions will put restrictions on these)
- integers (floating-point numbers will be added later)
  - all typical sizes (8,16,32,64)
- arrays
- base types (ADTs)
  - type expressions: | (union), & (intersection)
  - generics
  - product types (tuples, tagged tuples)
- classes/structs (structs are raw and have different inheritance rules than classes)
  - constructors
  - methods
  - fields
  - inheritance
  - static functions
- pure functions (functions that are just expressions)
  - function calls
  - operators (infix functions)
  - let-in expressions
  - where clauses
  - if-else expressions
  - tail recursion optimization
  - match expressions
  - FOR NOW: pure functions can call imperative functions, as long as they aren't void
- imperative functions (functions that are sequences of instructions)
  - can do everything that pure functions can, plus...
  - blocks/statements
  - loops: for, foreach, while, do-while
  - return
  - throw, try-catch, try-catch-finally (EXCEPTIONS, only imperative functions can deal with exceptions for now)
- quasi-pure functions (this is more complex but it is a central part of the language)
  - pure functions that look like imperative functions
  - assignments create new allocations, don't break old references
  - loops not allowed
  - any parameters modified will be implicitly returned, which leads to...
- function contexts (again, complex but central)
  - implicit parameters for quasi-pure functions, pure and imperative can access them explicitly
  - examples: 'this' for classes/structs, 'global' for mutable state
  - functions using contexts must explicitly declare them (except for 'this' and 'global'), callers will implicitly pass them
  - modified contexts will be implicitly returned so the caller will hold a new reference to the modified context
  - unmodified contexts
- 'this'
  - built-in context that makes it easier to mutate instances from methods in a pure way
  - always refers to an instance of the class containing the method
  - '<inst>.<blah>()' will pass 'inst' as 'this' into 'blah'
- 'global'
  - built-in context that provides access to impure code/state from pure code
  - anytime 'global' is used to access impure code/state, it returns a modified instance of itself
  - 'global' is passed implicitly into 'main', so it can be accessed anywhere in the application
- modules
  - modules' named exports can be imported individually
  - default export is used when only the module name is imported
  - modules can export named exports or default export
  - each imported module is evaluated according to node-esque rules
- 'main'
  - for now, this is the top-level of all applications
  - the specified module passed into the command line must contain 'main' so that the program can start
----

# Breaks are implicit in this grammar to improve clarity.
# A break is a new line or a semicolon, so semicolons are only required when putting multiple incompatible constructions on the same line

# A Program is a list of top-level components, which can be:
# - functions
# - types
# - classes
# - structs
# - import declarations
# - export declarations
# A stipulation is that import declarations must come before any other declaration
Program ::= ImportDeclaration* FreeDeclaration*
FreeDeclaration ::= ComponentDeclaration
                  | ExportDeclaration

ExportDeclaration ::= EXPORT DEFAULT Expression           -- default export
                    | EXPORT IDENT EQUALS Expression -- named inline export
                    | EXPORT IDENT                   -- named export of already declared name

ComponentDeclaration ::= FunctionDeclaration
                       | TypeDeclaration
                       | ClassDeclaration
                       | StructDeclaration

# pure <returnType> <name>\<<typeParameters>\>(<parameters>) => <expression>
# proc <returnType> <name>\<<typeParameters>\>(<parameters>) => <block>
# func <returnType> <name>\<<typeParameters>\>[<contextParameters>](<parameters>) => <quasiBlock>
FunctionDeclaration ::= PURE Type IDENT TypeParameterList? ParameterList FAT_ARROW Expression
                      | PROC Type IDENT TypeParameterList? ParameterList FAT_ARROW Block
                      | FUNC Type IDENT TypeParameterList? ContextParameterList? ParameterList FAT_ARROW QuasiBlock

TypeParameterList ::= LT GenericParam (COMMA GenericParam)* GT
ContextParameterList ::= LBRACK Param (COMMA Param)* RBRACK
ParameterList ::= LPAREN (Param (COMMA Param)*)? RPAREN

Param ::= Type IDENT

GenericParam ::= IDENT
               | IDENT COLON Type

# type <name>
# type <name> = <typeExpression>
# type <name> { <typeComponentDeclarations> }
# type <name>(<types>)
# type <name>(<type> <fieldName>...)
TypeDeclaration ::= TYPE IDENT
                  | TYPE IDENT EQUALS Type
                  | TYPE IDENT LBRACE TypeComponentDeclaration+ RBRACE
                  | TYPE IDENT LPAREN Type+ RPAREN
                  | TYPE IDENT LPAREN (Type IDENT)+ RPAREN

TypeComponentDeclaration ::= IDENT
                           | IDENT EQUALS