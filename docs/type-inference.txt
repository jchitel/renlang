Type Inference
--------------

Ideally, the developer should rarely, if ever, have to explicitly specify types if they don't want to.
The verbosity of specifying types is one of the biggest complaints of strongly-typed languages.
Newer strongly typed languages get around this by building intelligence into their compilers that
infers types based on usage, so developers don't always need to specify types.

When dealing with type inference, one often encounters the concept of "type flow".
When the type of one expression is inferred, that type flows through anywhere that the expression's value is used.
This cascades through an entire function, module, and program.
Because "downstream type flow" like this follows the same direction as the logic,
this is often very easy to follow, and in fact, Ren already has this type of inference.

Where this becomes difficult is the concept of "upstream type flow", which happens when you
want to infer the type of an expression that has no inherent type. This is almost always an identifier
such as a parameter, field, variable, or generic type parameter.
These constructs are just identifiers, references to other expressions that have types.
When the identifier declaration is paired directly with its initialization (for example,
a simple variable initialization), this is easy.
Simply get the type of the initializing expression, and assign that type to the identifier.
But for parameters, fields, or variables that are declared without an initializer,
the actual initialization can be occuring anywhere.
In the instance of fields or variables, this is still a "downstream" situation
because the initialization will occur after the declaration.
You can simply hold onto the identifier, wait for it to be used, then set its type.
Parameters (and anything that depends on them) are a different story entirely.
Parameters are placeholders for a value that will be passed into a function or type.
In order to infer their types, you need to either look for the usages of the parameters,
or look for the usages of the function that declares the parameters.
In this instance, you have a choice: base the type of the parameter on the parameter usage,
or the function usage.
In almost all cases, you want to use the parameter usage, otherwise the function becomes
dependent on how it is used rather than what it does, which is weird.
But in some cases the parameter usage is not sufficient, so that is another valid option.

Now how do we want this to work?
Ideally, you will start with the main function of the application and work your way through
all references in the program.
When you encounter an identifier with no type, you want to try to get its type from its
declaration before trying to get it from its usage.
This will involve tracking down the declaration and tracing through that.
This process will be heavily recursive.
If a declaration is processed and no type is inferred, you can then go on to usages.
Place the identifier into a table for "yet to be typed identifiers".
Whenever you encounter the usage of an identifier in the table, you should be able to
infer the type of the identifier from the context it is used.
If not, that's fine (but it needs to be determined whether this is possible).
Ideally, when you have finished traversing a program, you have been able to
assign types to everything.
If you haven't, the interesting thing to consider is that it may not even matter.
If a value is simply passed around, and no operation is done on it that applies to a specific type,
then a type need not be assigned to it.
The place the identifier's value came from, and the place its value went,
simply did not require a specific type.
The program should be just fine.

As of writing, the following language constructs can be tagged with a type:
- type declarations (obviously)
- function parameters
- function return types
- lambda function parameters
- type parameter constraints
- type arguments (applications of type parameters)
- struct/class fields
- array base types
- tuple types
- variables

Any non-identifier expression's type can be automatically inferred based on its inherent behavior.
Numbers can be inferred to have numeric types, likewise with other primitive types.
----- TBC



----- OLD NOTES

Right now, inference works in two ways:
- Expressions have inherent types, which flow through the places they are used, i.e. variables, method calls, operators, etc.
- Lambda function types (particularly return types) are inferred because they can only be used in method calls, which have strictly defined signatures.

This has a lot of limits. It's nice to say "types must be specified on parameters and return types and nowhere else" but this restricts the freedom of developers.
Plus it's nice to be able to specify as little information as possible and have the language just know what you mean (like Haskell).

We need to be able to do the following:
- Specify types nowhere, including:
  - Function parameters
  - Function return types
  - Lambda function expressions
  - Type arguments
  - Variables
  - Struct/class fields (maybe)
- Specify types in all the above, as well as:
  - Casts (see cast expressions below)

This means that types can be inferred by two ways:
- primitive expressions or already typed expressions bubbling up to where they are used
- usages of identifiers or expressions defining the type

This is very difficult but very powerful.
To start this, we define the concept that an expression has a base assignable type that is as general as it can possibly be, but it is not 100% inferred yet.
Or, if there is nothing inherent to the expression to define its type, then it simply has no type yet.
We assign these loose types to everything we can as we move through a function.
Anything that does not have a rock-solid type is added to an inference table with either its loose type or no type if it can potentially be any type.
Anywhere that a non-inferred expression is used, we compare the loose type (if any) to the expected type of the usage.
- If the assignment is valid, we can either further restrict the loose type or keep it
- If the expression had not been typed yet, it now has a loose type
- If the assignment is not valid, it is an error
- If the inference has restricted to one possible type, that type is now inferred
At the end of the function, any expression with a loose type gets that loose type.
Any expression without even a loose type is left alone.

A higher level pass will attempt to infer types across functions.
If a function's parameter types could not be inferred from the contents of the function, they may be inferrable from invocations of the function.

There are a few types that will never be valid to be inferred:
- any (these must be explicit)
- union types that have no logic to indicate that a union type is expected (also must be explicit)

The only restriction on type inference is across modules. Modules should not be coupled to one another in that manner.
If a module imports and uses a value that was not able to be inferred in the source module, this will be an error.
This behavior can be disabled from module configuration to add coupling to modules that may not be exposed to 3P consumers.