So, generic types.
Generic types are parameterized types.
That is, types whose definition is dependent on one or more variable input types, a.k.a. "type parameters".
To declare a generic type, you simply make a regular type declaration, but include type parameters.
Those parameters can be used anywhere in the type definition, including the following parameters.
Here are examples of each possible use of generic types:

type MyType<A> = A                // lonely type
type MyType<A> = A[]              // arrays
type MyType<A, B> = (A, B)        // tuples
type MyType<A, B> = { A a; B b }  // structs
type MyType<A, B> = (A) => B      // functions
type MyType<A, B> = A | B         // unions
type MyType<A> = MyOtherType<A>   // other generics

As you can see, type parameters can be used wherever a type is expected.
These are array base types, tuple component types, struct field types, function param and return types, union component types, lonely types, or even as type arguments for another generic type.
The last example shows how a generic type is used.
A type parameter can only be declared in a generic type declaration.
Once that generic type is used somewhere, a type *argument* must be provided to "fill in" that parameter.
That argument can be another type parameter, if so desired. Type parameters are types, so there's no reason this can't be done.
When a generic type is used and arguments are provided for its parameters, we call it a "specific type", because it is no longer generic.
Specific types resolve to whatever the generic type's definition is, with the type parameters replaced with the provided argument types.

Now, type declarations are not the only place where you might find type parameters, you can also use them in functions.

func int myFunc<A>(A a) => ...

Generic functions are functions with type parameters, where those type parameters are used in at least the parameters, but also potentially the return type, of the function.
Those type parameters may also flow into the logic in the body of the function.
This is a way to prevent the necessity for repetitive overloads for different parameters.
In this case, providing arguments for the function's type parameters happens when the function is invoked.
The invocation is processed by filling in the type parameters, and then determining the resulting return type.
The type parameters can also be inferred from the provided parameters to the function, so it is not always necessary to provide them explicitly.

Type parameters can also provide two types of constraints:
- Variance constraints
- Type constraints

Variance constraints control assignability between specific types, as well as assignability between types and type arguments.
There are three kinds of variance:
- Invariance
- Covariance
- Contravariance
Invariance on a type parameter indicates that, given two specific types of a generic type using that type parameter, the only valid assignability relationships are those where the arguments provided for that parameter exactly match. That is, the type argument of one must be both assignable from and to the type argument of the other. The same relationship must apply for assignability between a type and a specified type parameter in any case, such as in a function body. This is always the case when a type parameter is going to be used in both read and write scenarios, such as a mutable structure like an array or struct.
Covariance on a type parameter indicates that, given two specific types of a generic type using that type parameter, the only valid assignability relationships are those where the 'from' type argument is assignable to the 'to' type argument. This is always the case when a type parameter is going to be used only in read-only scenarios such as a function return type, or getting a value, but NOT write/set scenarios.
Contravariance is the opposite of covariance. The 'to' type argument must be assignable to the 'from' type argument, and not the other way around. This is always the case when a type parameter is going to be used only in write-only/set scenarios, such as a function parameter (and really not much else), but NEVER in a read/get scenario.
Variance is taken into account when working out where a type parameter is used. You can set a type parameter as covariant or contravariant explicitly, but if not Ren will infer the variance of the parameter based on where it is used. Anything that will be applied as a type parameter of a function must be either invariant or contravariant, anything else must be either covariant or invariant, and anything that will be used in both cases must be invariant.

There are several new logical problems that come with adding generic types:
- Specifying generic types
- Assignability to generic types
- Assignability to specific types
- Assignability to type parameters