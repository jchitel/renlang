So, generic types.
Generic types are parameterized types.
That is, types whose definition is dependent on one or more variable input types, a.k.a. "type parameters".
To declare a generic type, you simply make a regular type declaration, but include type parameters.
Those parameters can be used anywhere in the type definition, including the following parameters.
Here are examples of each possible use of generic types:

type MyType<A> = A                // lonely type
type MyType<A> = A[]              // arrays
type MyType<A, B> = (A, B)        // tuples
type MyType<A, B> = { A a; B b }  // structs
type MyType<A, B> = (A) => B      // functions
type MyType<A, B> = A | B         // unions
type MyType<A> = MyOtherType<A>   // other generics

As you can see, type parameters can be used wherever a type is expected.
These are array base types, tuple component types, struct field types, function param and return types, union component types, lonely types, or even as type arguments for another generic type.
The last example shows how a generic type is used.
A type parameter can only be declared in a generic type declaration.
Once that generic type is used somewhere, a type *argument* must be provided to "fill in" that parameter.
That argument can be another type parameter, if so desired. Type parameters are types, so there's no reason this can't be done.
When a generic type is used and arguments are provided for its parameters, we call it a "specific type", because it is no longer generic.
Specific types resolve to whatever the generic type's definition is, with the type parameters replaced with the provided argument types.

Now, type declarations are not the only place where you might find type parameters, you can also use them in functions.

func int myFunc<A>(A a) => ...

Generic functions are functions with type parameters, where those type parameters are used in at least the parameters, but also potentially the return type, of the function.
Those type parameters may also flow into the logic in the body of the function.
This is a way to prevent the necessity for repetitive overloads for different parameters.
In this case, providing arguments for the function's type parameters happens when the function is invoked.
The invocation is processed by filling in the type parameters, and then determining the resulting return type.
The type parameters can also be inferred from the provided parameters to the function, so it is not always necessary to provide them explicitly.

Type parameters can also provide two types of constraints:
- Variance constraints
- Type constraints

Variance constraints control assignability between specific types, as well as assignability between types and type arguments.
There are three kinds of variance:
- Invariance
- Covariance
- Contravariance

Invariance on a type parameter indicates that, given two specific types of a generic type using that type parameter,
the only valid assignability relationships are those where the arguments provided for that parameter exactly match.
That is, the type argument of one must be both assignable from and to the type argument of the other.
The same relationship must apply for assignability between a type and a specified type parameter in any case, such as in a function body.
This is always the case when a type parameter is going to be used in both read and write scenarios, such as a mutable structure like an array or struct.

Covariance on a type parameter indicates that, given two specific types of a generic type using that type parameter,
the only valid assignability relationships are those where the 'from' type argument is assignable to the 'to' type argument.
This is always the case when a type parameter is going to be used only in read-only scenarios such as a function return type,
or getting a value, but NOT write/set scenarios.

Contravariance is the opposite of covariance.
The 'to' type argument must be assignable to the 'from' type argument, and not the other way around.
This is always the case when a type parameter is going to be used only in write-only/set scenarios, such as a function parameter (and really not much else),
but NEVER in a read/get scenario.

Variance is taken into account when working out where a type parameter is used.
You can only set a type parameter as covariant or contravariant explicitly; parameters are always invariant by default.
Anything that will be applied as a parameter of a function must be either invariant or contravariant,
anything else must be either covariant or invariant, and anything that will be used in both cases must be invariant.
This logic may be adjusted one day to always be implicit.

Variance does NOT apply when dealing with type parameters themselves.
Any unset type parameter can be set to any type (ignoring the type constraint).
It is only when there IS a set type parameter that variance applies:
- A specific type of a generic type is attempted to be assigned to another specific type of the same generic type.
  - In this case the variance of each type parameter is checked to determine the assignability between the type arguments.
- A type parameter is set with a type argument, and a type is attempted to be used in an instance of that type parameter.
  - In this case the instance of the type parameter preserves the variance information to determine assignability.
  - THIS MAY NOT BE NECESSARY

Type constraints control which types are allowed to be assigned to type parameters.
As of now there is only one type of type constraint: an assignability constraint.
These constraints are useful when you want to ensure that values of the type parameter's type have at least a certain type's behavior.
A type constraint means that the only allowed types are those that are assignable to the provided type.

Type constraints apply any time a type is being assigned to a type parameter.
Once a type parameter is set, they will no longer come into play.

There are several new logical problems that come with adding generic types:
- Specifying generic types
- Assignability to generic types
- Assignability to specific types
- Assignability to type parameters

When **specifying a generic type**, all that applies is type constraints.
Whatever type is provided has to satisfy the constraint, and then the constraint no longer applies.

Technically, it is not possible to **assign to a generic type**.
Any usage of a generic type has to incorporate the type parameters, meaning that something has to be provided for the type parameters.
This means that it will no longer be generic, but specific, even if other type parameters from a containing type or function are used as arguments.

**Assignability to specific types** works just like any other type primarily.
The underlying types are compared with the type parameters filled in.
Any time one of the types is a type parameter, the variance is used to determine if the assignment is valid.