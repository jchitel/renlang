
Ok, so now that we have a working translator step, the next step is the interpreter.
But it's kinda hard to test a lot of that without a standard library.
So now it's time to work on that.

Here are the high level components that need to be included:
- implementations of built-in type operations:
  - arrays:
    - setting index values (REQUIRES ARRAY SET STATEMENT)
    - creating dynamically sized arrays (REQUIRES GENERICS)
    - other common operations (pretty much all of which REQUIRE GENERICS)
  - structs:
    - setting values (REQUIRES FIELD SET STATEMENT)
    - other common operations (copy, etc.)
  - tuples:
    - extracting values (REQUIRES OVERLOADS or DESTRUCTURING)
- simple operations
  - truthy (true if the value satisfies truthy rules, false otherwise)
    - a value is truthy if it does not represent nothing, i.e. a non-empty array, tuple, or struct, and any number/char that is not 0 or NaN, the true value
  - chr (return the character represented by a number)
  - flt (convert a value to a floating point value)
- functional/transformer operations (REQUIRES GENERICS)
  - map
  - filter
  - reduce
  - flatMap
  - all/any (true if all/any elements satisfy the predicate)
- streams (REQUIRES GENERICS)
- starting new processes
- invoking CLI commands
- IO
  - File IO (abstractions for files)
  - CLI IO (abstractions for CLI)
    - format
    - print
    - input
    - readChar
  - Network IO (abstractions for network)
- errors/exceptions
- event-based programming
  - runtime setup of JS event queue
  - task/wait functionality
- File system
  - path manipulation
- Web
  - HTTP abstractions
  - API library
- OS
  - OS resolution
  - low-level operation access
- Math
  - abs
  - complex (creates a complex number struct)
  - divmod (does division and modulo at the same time, returning a tuple of both values)
  - floor/ceil
- Data structures (REQUIRES GENERICS)
  - maps
  - lists
  - sets
- logging
- regex

Here are specific APIs that we have discovered that are required during the process of translating the compiler code to Ren:
- module "fs/io" (reading/writing files)
  - TextStream readFile(string path) (reads a file at the specified path and returns a text stream for that file's contents)
  - class TextStream (a lazy sequence of characters, useful as a buffer for reading text from a file or other IO text source)
    - string toString() (reads all text from the stream and returns it in one string)
- module "core/prelude" (core standard library, prelude declarations which are automatically included)
  - type Array<T> (contains operations for arrays)
    - Array<T> slice(int start) (returns a new array with the first (start) entries stripped)
    - Array<T> slice(int start, int end) (returns a new array with the first (start) entries stripped, up to and not including the (end)-th entry)
    - Array<T2> map<T2>((T) => T2 mapper) (returns a new array containing the result of calling mapper on each element in the original array)
    - T max() (if this is an array of ordered values, returns the highest one, otherwise throws an error)
    - int length { get } (property that provides the length of the array)
    - void add(T elem) (adds an element to the end of an array)
    - bool any() (returns true if the length of the array is greater than 0)
  - Array<T> range<T : Ordered>(T start, T end) (given a start and end ordered value, return an array containing every value between the two values)
  - Array<T> range<T : Ordered>(T end) (same as above, but with an implied 0 as the start)
  - Array<T> range<T : Ordered>(T start, T end, int increment) (same as first overload, but with an incrementer)
  - interface Iterable<T> (provides an iterator)
    - Iterator<T> getIterator()
  - interface Iterator<T> (provides an interface for iteration)
    - { T next; bool done } next()
  - type Maybe<T> (jerry-rigged optional type, we will need TRUE sum types for this to work correctly)
    - type Some<T> { T value } (constructed via some(T))
    - type None {} (constructed via nothing value)
  - Error (base error class)